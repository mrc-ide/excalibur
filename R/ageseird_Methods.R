#' @include agesird_Class.R
#' @include currentState_Generics.R
NULL

#' An S4 method to calculate current state of an object of the ageseirdModel class
#'
#' Calls two generic functions to calculate the downstream nodes and estimate
#' the infectious population in turn.
#'
#' @param epiModel An age-SEIRD model, whose current state is to be calculated.
#' @param deaths The total death count for this model, up to each of the
#' changeTimes so far.
#' @param nderiv Which derivatives of D to assume is sum to 0.
#' @param plotDeriv True/False that tells the function to plot the derivative
#' of D determined by nderiv.
#' @return An ageseirdModel of object.
#' @examples
#' #set up model
#' model <- setAgeSIRD(N = c(100,100), Betas = matrix(c(1,0.5,0.2,1), nrow=2, byrow=TRUE),
#' Gamma = 1/5, Lambda = 1/2, ProbOfDeath = 1/20, I0 = c(1,1))
#' #Set the deaths
#' deaths <- matrix(c(10,20), nrow = 1, ncol = 2)
#' time <- 10
#' #calculate current state
#' model <- calculateCurrentState(model, time, deaths)
#' #return the current state
#' currentState(model)
#' @export
setMethod("calculateCurrentState", signature("ageseirdModel"),
          function(epiModel, deaths, nderiv=8, plotDeriv = FALSE){
            #ensure deaths is a matrix with no names
            names(deaths) <- NULL
            deaths <- as.matrix(deaths)
            epiModel <- calculateDownstreamExponentialNodes(epiModel, deaths)
            epiModel <- estimateInfectiousNode(epiModel, deaths, nderiv, plotDeriv)
            return(epiModel)
          }
)
#' An S4 method to estimate current state of S, E and I for an age-structured
#' SEIRD when provided with a total count of deaths so far
#'
#' Please note that this method does not guarantee that this state would be
#' generated by the model, given its initial conditions.
#' This method uses the methods for an SIRD model to calculate S and R
#' This method also makes the assumption that the sum of the absolute values of
#' the nth derivatives of D with respect to time is 0. N is set by nderiv with a
#' default of 8. This equation is then solved for I using optim, hence this
#' method returns a close but non-exact solution for E and I.
#' These values are then stored in the list in the slot "currentState".
#'
#' @param epiModel The epidemic model of class age-SEIRD to have the current state of
#' S and I estimated.
#' @param deaths A matrix of the total death count for this model, up to each of the
#' changeTimes so far.
#' @param nderiv Which derivative to assume is 0.
#' @param plotDeriv True/False that tells the function to plot the derivative
#' of D determined by nderiv.
#' @return An object of class seirdModel with the values for S, E and I updated
#' for the current state.
#' @examples
#' #model with time-varying Beta
#' Betas <- array(NA, dim=c(2,2,2)) #set up array, the first dimension will be time
#' Betas[1,,] <- matrix(c(1,0.5,
#'                        0.2,1), nrow=2, byrow = TRUE)
#' Betas[2,,] <- matrix(c(1,0.1,
#'                        0,5), nrow=2, byrow = TRUE)
#' model <- setAgeSIRD(N = c(100,100), Betas = Betas, nrow=2, byrow=TRUE),
#' Gamma = 1/5, Lambda = 1/2, ProbOfDeath = 1/20, I0 = c(1,1), changeTimes = 5)
#' #Set the deaths
#' deaths <- matrix(c(5, 10,
#'                    10,20), nrow = 1, ncol = 2)
#' time <- 10
#' #calculate current state
#' model <- calculateCurrentState(model, time, deaths)
#' #return the current state
#' currentState(model)
#'
#' @export
setMethod("estimateInfectiousNode", signature("ageseirdModel"),
          function(epiModel, deaths, nderiv, plotDeriv){
            #call the SIRD method
            epiModel <- methods::selectMethod(estimateInfectiousNode, "agesirdModel")(
              epiModel,
              deaths
            )
            #get parameters/current state
            S <- epiModel@currentState$S
            D <- epiModel@currentState$D
            R <- epiModel@currentState$R
            N <- epiModel@initialState$N
            #get the desired derivative
            deriv <- getNthDeriv(epiModel, nderiv)
            #if its not there
            if(identical(deriv,NA)){
              #calculate the desired derivative
              message(paste0("The ", nderiv, "-th Derivative has not been
                             included and will now be calculated."))
              deriv <- calculateNthDeriv(epiModel, nderiv)
            }
            #calculate the scaling factor
            I <- N - S - D - R
            scalingFactor <- abs(deriv(epiModel, I))
            I <- rep(0, length(N))
            scalingFactor <- (scalingFactor + abs(deriv(epiModel, I)))/2

            #set up optimization function
            optimFunc <- function(I){
              return(sum((deriv(epiModel, I)/scalingFactor)^2))
            }
            #optimise
            resultMessage <- rep(NA, 3)
            resultPar <- matrix(NA, nrow = 3, ncol = 3)
            resultValue <- rep(NA, 3)
            startingValues <- matrix(c(
              rep(0,length(N)),
              (N - S - D - R)/2,
              N - S - D - R),
              ncol = 3)
            for(i in 1:3){
              result <- stats::optim(startingValues[,i], optimFunc, method = "L-BFGS-B", lower = rep(0, length(N)), upper = N-S-D-R)
              resultMessage[i] <- result$message
              if(result$convergence == 0 & all(result$par != startingValues[,i])){
                resultPar[,i] <- result$par
                resultValue[i] <- result$value
              }
            }
            if(all(is.na(resultPar))){
              stop(paste0("Optim failed to converge, consider reducing nderiv ", paste(resultMessage, collapse = " ")))
            }
            #remove NAs
            resultPar <- resultPar[,!is.na(colSums(resultPar))]
            #take the result with the lowest value
            if(is.matrix(resultPar)){
              resultValue <- resultValue[!is.na(resultValue)]
              I <- resultPar[,which.min(resultValue)]
            } else{
              I <- resultPar
            }
            #plotting
            if(plotDeriv){
              for(group in 1:length(N)){
                xValues <- seq(0, N[group]-S[group]-D[group]-R[group], length.out = 200)
                yValues <- rep(NA, 200)
                for(i in 1:200){
                  xValue <- I
                  xValue[group] <- xValues[i]
                  yValues[i] <- optimFunc(xValue)
                }
                oldValue <- graphics::par()$mar
                graphics::par(mar = c(oldValue[1], 6, oldValue[3], oldValue[4]))
                graphics::plot(xValues, yValues, type="l", xlab=paste0("I[", group, "]"), ylab = bquote(f(I) %prop% sum((frac(d^.(nderiv)*D[a]*(t), d*t^.(nderiv)))^2, a)))
                graphics::abline(v=I[group])
                graphics::abline(v=startingValues[group,], lty = 2)
                graphics::par(mar=oldValue)
              }
            }
            #assign
            epiModel@currentState$I <- I
            epiModel@currentState$E <- N - S - D - R - I
            return(epiModel)
          }
)
#' An s4 method for deriving the n-th derivative of D(t) for the age-SEIRD model.
#' @noRd
setMethod("calculateNthDeriv", signature("ageseirdModel"),
          function(epiModel, nderiv){
            #find the number of groups
            groups <- length(epiModel@initialState$N)
            #functions to derive around
            Sf <- function(t,group){}
            Df <- function(t,group){}
            Rf <- function(t,group){}
            If <- function(t,group){}
            Ef <- function(t,group){}
            #Place holder values to prevent a note in RMD_Check, these are
            #undefined variables are replace in the function surgery later
            Alpha <- NA
            Beta <- NA
            Gamma <- NA
            Lambda <- NA
            N <- NA
            #setup derivatives
            drule <- Deriv::drule #a copy of the derivative rules from Deriv
            #write out SE transitions
            equation <- "Sf(t,group)*("
            for(i in 1:groups){
              equation <- paste0(equation,"Beta[", i, ",group]*If(t,",
                                 i, ")/N[",i,"]")
              if(i != groups){
                equation <- paste0(equation,"+")
              } else{
                equation <- paste0(equation,")")
              }
            }
            drule[["Sf"]] <- NULL
            drule[["Sf"]]$t <- str2lang(paste0("-", equation))
            drule[["Ef"]] <- NULL
            drule[["Ef"]]$t <- str2lang(paste0(equation, " - Lambda*Ef(t,group)"))
            drule[["If"]] <-alist(t=Lambda*Ef(t,group) - (Alpha + Gamma)*If(t,group))
            drule[["Df"]] <-alist(t=Alpha*If(t,group))
            drule[["Rf"]] <-alist(t=Gamma*If(t,group))
            #use Deriv to calculate nth derivative
            nthDf <- Deriv::Deriv(Df, "t", nderiv = 7, drule=drule)

            #must perform "function surgery" to make this usable
            #set arguments
            formals(nthDf) <- alist(epiModel = , I = )
            #extract function code
            code <- deparse(body(nthDf))
            #replacing functions with values
            code <- gsub("If\\(t, group\\)", "I", code)
            code <- gsub("Ef\\(t, group\\)", "E", code)
            code <- gsub("Sf\\(t, group\\)", "epiModel@currentState$S", code)
            code <- gsub("N", "epiModel@initialState$N", code)
            for(i in 1:groups){
              code <- gsub(paste0("If\\(t, ", i, "\\)"), paste0("I[", i, "]"), code)
              code <- gsub(paste0("Ef\\(t, ", i, "\\)"), paste0("E[", i, "]"), code)
              code <- gsub(paste0("Sf\\(t, ", i, "\\)"), paste0("epiModel@currentState$S[", i, "]"), code)
            }
            code <- gsub("group", "", code)
            #replace all parameters etc with calls to the relevant slot
            for(parameter in c("Lambda","Alpha","Gamma")){
              code <- gsub(parameter, paste0("epiModel@parameters$",parameter), code)
            }
            #add a line of code to calculate E and Beta
            if(length(code) == 1){
              code <- c("{",
                        "Beta <- epiModel@parameters$Betas[whichIndex(epiModel@currentState$t, epiModel@parameters$changeTimes),,]",
                        "E <- (epiModel@initialState$N - epiModel@currentState$S - epiModel@currentState$D - epiModel@currentState$R - I)",
                        code,
                        "}")
            } else{
              code <- c(code[1],
                        "Beta <- epiModel@parameters$Betas[whichIndex(epiModel@currentState$t, epiModel@parameters$changeTimes),,]",
                        "E <- (epiModel@initialState$N - epiModel@currentState$S - epiModel@currentState$D - epiModel@currentState$R - I)",
                        code[2:length(code)])
            }
            #add code back to body
            body(nthDf) <- parse(text=code)
            return(nthDf)
          }
)
