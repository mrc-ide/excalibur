#' @include currentState_Generics.R
NULL
#' An S4 method to calculate current state of an object of the agesirdModel class
#'
#' Calls two generic functions to calculate the downstream nodes and estimate
#' the infectious population in turn.
#'
#' @param epiModel An agesird model, whose current state is to be calculated.
#' @param deaths The total death count for each age-group in this model,
#' up to each of the changeTimes so far. Rows relate to age groups and columns
#' to changeTimes.
#' @return An agesirdModel object.
#' @examples
#' #set up model
#' model <- setAgeSIRD(N = c(100,100), Betas = matrix(c(1,0.5,0.2,1), nrow=2, byrow=TRUE),
#'                     Gamma = 1/5, ProbOfDeath = 1/20, I0 = c(1,1))
#' #Set the deaths
#' deaths <- matrix(c(10,20), nrow = 1, ncol = 2)
#' time <- 10
#' #calculate current state
#' model <- calculateCurrentState(model, time, deaths)
#' #return the current state
#' currentState(model)
#' @export
setMethod("calculateCurrentState", signature("agesirdModel"),
          function(epiModel, deaths){
            #ensure deaths is a matrix with no names
            names(deaths) <- NULL
            deaths <- as.matrix(deaths)
            epiModel <- calculateDownstreamExponentialNodes(epiModel, deaths)
            epiModel <- estimateInfectiousNode(epiModel, deaths)
            return(epiModel)
          }
)
#' An S4 method to calculate current state of R and D for an ageSIRD/ageSEIRD when
#' provided with a count of the total number of deaths for each age-group.
#'
#' Please note that this method does not guarantee that this state would be
#' generated by the model, given its initial conditions.
#' Calculates the number of people in the recovered state by scaling D by the
#' rate of recovery divided by the rate of death.
#' These values are then stored in the list in the slot "currentState".
#'
#' @param epiModel The epidemic model of class age-SIRD to have the current
#' state of R and D calculated.
#' @param deaths The total death count for this model, so far.
#' @return An object of class agesirdModel with the values for D and
#' R updated for the current state.
#' @examples
#' #create example model
#' model <- setAgeSIRD(N = c(100,100), Betas = matrix(c(1,0.5,0.2,1), nrow=2, byrow=TRUE),
#'                     Gamma = 1/5, ProbOfDeath = 1/20, I0 = c(1,1))
#' #Set the deaths (only one vector is required)
#' deaths <- matrix(c(20,50), byrow=TRUE, ncol = 2)
#' #call this function
#' model <- excalibur::calculateDownstreamExponentialNodes(model, deaths=deaths)
#'
#' currentState(model)
#' @export
setMethod("calculateDownstreamExponentialNodes", signature("agesirdModel"),
          function(epiModel, deaths){
            totalDeaths <- as.vector(deaths[nrow(deaths),], mode = "double")
            #this removes any names etc.
            #check for errors in deaths
            agesird_Methods_errorChecks(epiModel, deaths, totalDeaths)
            #Get model parameters
            Alpha <- epiModel@parameters$Alpha
            Gamma <- epiModel@parameters$Gamma
            D0 <- epiModel@initialState$D0
            R0 <- epiModel@initialState$R0
            #Calculate the number of recoveries
            R <- (totalDeaths - D0) * Gamma/Alpha + R0
            #Assigning
            epiModel@currentState$D <- totalDeaths
            epiModel@currentState$R <- R
            return(epiModel)
          }
)
#' An S4 method to estimate current state of S and I for an age-SIRD when provided
#' with a total count of deaths so far
#'
#' Please note that this method does not guarantee that this state would be
#' generated by the model, given its initial conditions.
#' Due to rounding etc, when the value of I would be very small the estimated I
#' will be quite different from the one generated when the model is simulated.
#' These values are then stored in the list in the slot "currentState".
#'
#' @param epiModel The epidemic model of class age-SIRD to have the current state of
#' S and I estimated.
#' @param deaths The total death count for this model, up to each of the
#' changeTimes so far. Rows relate to changeTimes and columns to age groups.
#' @return An object of class agesirdModel with the values for S and I updated
#' for the current state.
#' @examples
#' #create example model
#' model <- setAgeSIRD(N = c(100,100), Betas = matrix(c(1,0.5,0.2,1), nrow=2, byrow=TRUE),
#'                     Gamma = 1/5, ProbOfDeath = 1/20, I0 = c(1,1))
#' #Set the deaths (only one entry is required)
#' deaths <- matrix(c(20,50),byrow=TRUE, ncol = 2)
#' #Set the time, makes no difference to this calculation, only used for simulate
#' time <- 10
#' #call this + the D+R node function
#' model <- calculateCurrentState(model, time, deaths)
#'
#' #check S and I
#' currentState(model)
#'
#' #model with time-varying Beta
#' Betas <- array(NA, dim=c(2,2,2)) #set up array, the first dimension will be time
#' Betas[1,,] <- matrix(c(1,0.5,
#'                        0.2,1), nrow=2, byrow = TRUE)
#' Betas[2,,] <- matrix(c(1,0.1,
#'                        0,5), nrow=2, byrow = TRUE)
#' model <- setAgeSIRD(N = c(100,100), Beta = Betas,
#'                     Gamma = 1/5, ProbOfDeath = 1/20, I0 = c(1,1), changeTimes = 5)
#' #Set the deaths, two columns are required now
#' deaths <- matrix(c(10,20,
#'                    30,50),byrow=TRUE, ncol = 2)
#' time <- 10
#' #the model assumes that the first number 20 is the number of deaths up to the
#' #specified change time 5, and that the last number 30 is the number of deaths
#' #up to the current time (10).
#' #if the current state is not past 5, then we would set the final column identical
#' #to the one before
#'
#' #call this + the D+R node function
#' model <- calculateCurrentState(model, t=time, deaths=deaths)
#'
#' #check S and I
#' currentState(model)
#'
#' @export
setMethod("estimateInfectiousNode", signature("agesirdModel"),
          function(epiModel, deaths){
            #check for errors in death specification
            agesird_Methods_errorChecks(epiModel, deaths, deaths[nrow(deaths),])
            #get model parameters
            Alpha <- epiModel@parameters$Alpha
            Gamma <- epiModel@parameters$Gamma
            Betas <- epiModel@parameters$Betas
            changeTimes <- epiModel@parameters$changeTimes
            S0 <- epiModel@initialState$S0
            I0 <- epiModel@initialState$I0
            R0 <- epiModel@initialState$R0
            D0 <- epiModel@initialState$D0
            N <- epiModel@initialState$N
            #more errors checks
            if(nrow(deaths) != dim(Betas)[1] | dim(Betas)[1] != length(changeTimes)){
              stop("'deaths' should be a cumulative time series counting the
                      total number of deaths up to a change time for Beta. This
                      means that nrow(deaths) = dim(Beta)[1] = length(changeTimes) + 1.")
            }
            else if(any(t(deaths) - D0 < 0)){
              stop("'deaths' is lower than the initial number of deaths D0")
            }
            #add initial states and changes over each beta value
            newD <-diff(
              #convert to matrix so we can use diff()
              rbind(D0, deaths)
            )
            #Calculate S
            S <- rep(NA, length(S0))
            for(a in seq_along(S)){
              S[a] <- S0[a]*exp(-(1/Alpha)* #scale by death rate
                                  sum(#sum of the weights
                                    t(t(newD*Betas[,,a])/N) #infectious weight for each age-group to this one
                                    )
                                )
            }
            #Calculate I
            I <- N - S - epiModel@currentState$R - epiModel@currentState$D
            #assign to list
            #Assigning
            epiModel@currentState$S <- S
            epiModel@currentState$I <- I
            return(epiModel)
          }
)
#' Internal function to run repeat error checks for the SIRd methods
#' @noRd
agesird_Methods_errorChecks <- function(epiModel, deaths, totalDeaths){
  if(nrow(deaths) != length(epiModel@parameters$changeTimes) |
     ncol(deaths) != length(epiModel@initialState$N)){
    stop("deaths has incorrect dimensions")
  } else if(!is.numeric(deaths)){
    stop("deaths must be numeric")
  }
  #checking deaths are in the correct format
  else if(any(t(deaths) - totalDeaths > 0)){
    stop("deaths must be a series of the cumulative number of deaths up to this time.")
  }
  #checking there are not more deaths than people in model
  else if(any(totalDeaths > epiModel@odinModel$contents()$S0 +
     epiModel@odinModel$contents()$I0 +
     epiModel@odinModel$contents()$R0 +
     epiModel@odinModel$contents()$D0)){
    stop("deaths exceeds model population (N)")
  }
  #if prob of death  = 0
  else if(epiModel@odinModel$contents()$Alpha == 0){
    stop("Since there is no chance of death in this model, it cannot
                   be fit using death data.")
  }
}
