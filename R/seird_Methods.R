#' An S4 method to calculate current state of an object of the seirdModel class
#'
#' Calls two generic functions to calculate the downstream nodes and estimate
#' the infectious population in turn.
#'
#' @param epiModel An SEIRD model, whose current state is to be calculated.
#' @param deaths The total death count for this model, up to each of the
#' changeTimes so far.
#' @param nderiv Which derivative of D to assume is 0.
#' @param plotDeriv True/False that tells the function to plot the dervivative
#' of D determined by nderiv.
#' @return An seirdModel of object.
#' @examples
#' #set up model
#' model <- setSEIRD(N = 100, Beta = 1, Gamma = 1/5, Lambda = 1/3, ProbOfDeath = 0.5, I0 = 1)
#' #Set the deaths
#' deaths <- 20
#' time <- 10
#' #calculate current state
#' model <- calculateCurrentState(model, time, deaths)
#' #return the current state
#' currentState(model)
#' @export
setMethod("calculateCurrentState", signature("seirdModel"),
          function(epiModel, deaths, nderiv=6, plotDeriv = FALSE){
            epiModel <- calculateDownstreamExponentialNodes(epiModel, deaths)
            epiModel <- estimateInfectiousNode(epiModel, deaths, nderiv, plotDeriv)
            return(epiModel)
          }
)
#' An S4 method to estimate current state of S, E and I for an SEIRD when provided
#' with a total count of deaths so far
#'
#' Please note that this method does not guarantee that this state would be
#' generated by the model, given its initial conditions.
#' This method uses the methods for an SIRD model to calculate S and R
#' This method also makes the assumption that the nth derivative of D with
#' respect to time is 0. N is set by nderiv with a default of 8.
#' This equation is then solved for I using optim, hence this method returns a
#' close but non-exact solution for E and I.
#' These values are then stored in the list in the slot "currentState".
#'
#' @param epiModel The epidemic model of class SEIRD to have the current state of
#' S and I estimated.
#' @param deaths The total death count for this model, up to each of the
#' changeTimes so far.
#' @param nderiv Which derivative to assume is 0.
#' @param plotDeriv True/False that tells the function to plot the derivative
#' of D determined by nderiv.
#' @return An object of class seirdModel with the values for S, E and I updated
#' for the current state.
#' @examples
#' #model with time-varying Beta
#' model <- setSEIRD(N = 100, Beta = c(2,1/2), Lambda = 1, Gamma = 1/5, ProbOfDeath = 0.5,
#'  I0 = 1, changeTimes = 5)
#' #Set the deaths, two entries are required now
#' deaths <- c(20,30)
#' time <- 10
#'
#' #call this method via calculate current state
#' model <- calculateCurrentState(model, t=time, deaths=deaths, nderiv = 8)
#'
#' #check S and I
#' currentState(model)
#'
#' @export
setMethod("estimateInfectiousNode", signature("seirdModel"),
          function(epiModel, deaths, nderiv, plotDeriv){
            #call the SIRD method
            epiModel <- methods::selectMethod(estimateInfectiousNode, "sirdModel")(
              epiModel,
              deaths
            )
            #get parameters/current state
            S <- epiModel@currentState$S
            D <- epiModel@currentState$D
            R <- epiModel@currentState$R
            N <- epiModel@initialState$N
            #get the desired derivative
            deriv <- getNthDeriv(epiModel, nderiv)
            #if its not there
            if(identical(deriv,NA)){
              #calculate the desired derivative
              message(paste0("The ", nderiv, "-th Derivative has not been
                             included and will now be calculated."))
              deriv <- calculateNthDeriv(epiModel, nderiv)
            }
            #calculate the scaling factor
            I <- N - S - D - R
            scalingFactor <- abs(deriv(epiModel, I))
            I <- 0
            scalingFactor <- (scalingFactor + abs(deriv(epiModel, I)))/2

            #set up optimization function
            optimFunc <- function(I){
              return((deriv(epiModel, I)/scalingFactor)^2)
            }
            #optimise
            resultMessage <- rep(NA, 3)
            resultPar <- rep(NA, 3)
            resultValue <- rep(NA, 3)
            startingValues <- seq(0, N-S-D-R, length.out=3)
            for(i in 1:3){
              result <- stats::optim(startingValues[i], optimFunc, method = "L-BFGS-B", lower = 0, upper = N-S-D-R)
              resultMessage[i] <- result$message
              if(result$convergence == 0 & (result$par != startingValues[i])){
                resultPar[i] <- result$par
                resultValue[i] <- result$value
              }
            }
            #plotting
            if(plotDeriv){
              xValues <- seq(0, N-S-D-R, length.out = 200)
              yValues <- optimFunc(xValues)
              oldValue <- graphics::par()$mar
              graphics::par(mar = c(oldValue[1], 6, oldValue[3], oldValue[4]))
              graphics::plot(xValues, yValues, type="l", xlab="I", ylab = bquote(f(I) %prop% (frac(d^.(nderiv)*D*(t), d*t^.(nderiv)))^2))
              graphics::abline(v=resultPar)
              graphics::abline(v=startingValues, lty = 2)
              graphics::par(mar=oldValue)
            }
            if(all(is.na(resultPar))){
              stop(paste0("Optim failed to converge, consider reducing nderiv ", paste(resultMessage, collapse = " ")))
            }
            #remove NAs
            resultPar <- resultPar[!is.na(resultPar)]
            resultValue <- resultValue[!is.na(resultValue)]
            #take the result with the lowest value
            I <- resultPar[which.min(resultValue)]
            #assign
            epiModel@currentState$I <- I
            epiModel@currentState$E <- N - S - D - R - I
            return(epiModel)
          }
)

#' An s4 method for deriving the n-th derivative of D(t) for the SEIRD model.
#' @noRd
setMethod("calculateNthDeriv", signature("seirdModel"),
          function(epiModel, nderiv){
            Sf <- function(t){}
            Df <- function(t){}
            Rf <- function(t){}
            If <- function(t){}
            Ef <- function(t){}
            #Place holder values to prevent a note in RMD_Check, these are
            #undefined variables are replace in the function surgery later
            Alpha <- NA
            Beta <- NA
            Gamma <- NA
            Lambda <- NA
            N <- NA
            #setup derivatives
            drule <- Deriv::drule #a copy of the derivative rules from Deriv
            drule[["Sf"]] <-alist(t=-Beta*If(t)*Sf(t)/N)
            drule[["Ef"]] <-alist(t=Beta*If(t)*Sf(t)/N - Lambda*Ef(t))
            drule[["If"]] <-alist(t=Lambda*Ef(t) - (Alpha + Gamma)*If(t))
            drule[["Df"]] <-alist(t=Alpha*If(t))
            drule[["Rf"]] <-alist(t=Gamma*If(t))
            #use Deriv to calculate nth derivative
            nthDf <- Deriv::Deriv(Df, "t", nderiv = nderiv, drule=drule)
            #must perform "function surgery" to make this usable
            #set arguments
            formals(nthDf) <- alist(epiModel = , I = )
            #extract function code
            code <- deparse(body(nthDf))
            #replacing functions with values
            code <- stringr::str_replace_all(code, "If\\(t\\)", "I")
            code <- stringr::str_replace_all(code, "Ef\\(t\\)", "(N - epiModel@currentState$S - epiModel@currentState$D - epiModel@currentState$R - I)")
            code <- stringr::str_replace_all(code, "Sf\\(t\\)", "epiModel@currentState$S")
            code <- stringr::str_replace_all(code, "N", "epiModel@initialState$N")
            #replace all parameters etc with calls to the relevant slot
            for(parameter in c("Lambda","Alpha","Gamma")){
              code <- stringr::str_replace_all(code, parameter,
                                      paste0("epiModel@parameters$",parameter))
            }
            #add a line of code to calculate N and Beta
            if(length(code) == 1){
              code <- c("{",
                        "Beta <- epiModel@parameters$Betas[whichIndex(epiModel@currentState$t, epiModel@parameters$changeTimes)]",
                        code,
                        "}")
            }
            else{
              code <- c(code[1],
                        "Beta <- epiModel@parameters$Betas[whichIndex(epiModel@currentState$t, epiModel@parameters$changeTimes)]",
                        code[2:length(code)])
            }
            #add code back to body
            body(nthDf) <- parse(text=code)
            return(nthDf)
          }
)
