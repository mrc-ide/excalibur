#' An S4 method to calculate current state of an object of the seirdModel class
#'
#' Calls two generic functions to calculate the downstream nodes and estimate
#' the infectious population in turn.
#'
#' @param epiModel An SEIRD model, whose current state is to be calculated.
#' @param deaths The total death count for this model, up to each of the
#' changeTimes so far.
#' @param nderiv Which derivative of D to assume is 0.
#' @return An seirdModel of object.
#' @examples
#' #set up model
#' model <- setSEIRD(N = 100, Beta = 1, Gamma = 1/5, Lambda = 1/3, ProbOfDeath = 0.5, I0 = 1)
#' #Set the deaths
#' deaths <- 20
#' time <- 10
#' #calculate current state
#' model <- calculateCurrentState(model, time, deaths)
#' #return the current state
#' currentState(model)
#' @export
setMethod("calculateCurrentState", signature("seirdModel"),
          function(epiModel, deaths, nderiv=6){
            epiModel <- calculateDownstreamExponentialNodes(epiModel, deaths)
            epiModel <- estimateInfectiousNode(epiModel, deaths, nderiv)
            return(epiModel)
          }
)#' An S4 method to estimate current state of S, E and I for an SEIRD when provided
#' with a total count of deaths so far
#'
#' Please note that this method does not guarantee that this state would be
#' generated by the model, given its initial conditions.
#' This method uses the methods for an SIRD model to calculate S and R
#' This method also makes the assumption that the nth derivative of D with
#' respect to time is 0. N is set by nderiv with a default of 8.
#' This equation is then solved for I using optim, hence this method returns a
#' close but non-exact solution for E and I.
#' These values are then stored in the list in the slot "currentState".
#'
#' @param epiModel The epidemic model of class SEIRD to have the current state of
#' S and I estimated.
#' @param deaths The total death count for this model, up to each of the
#' changeTimes so far.
#' @param nderiv Which derivative to assume is 0.
#' @return An object of class seirdModel with the values for S, E and I updated
#' for the current state.
#' @examples
#' #model with time-varying Beta
#' model <- setSEIRD(N = 100, Beta = c(2,1/2), Lambda = 1, Gamma = 1/5, ProbOfDeath = 0.5,
#'  I0 = 1, changeTimes = 5)
#' #Set the deaths, two entries are required now
#' deaths <- c(20,30)
#' time <- 10
#'
#' #call this method via calculate current state
#' model <- calculateCurrentState(model, t=time, deaths=deaths, nderiv = 8)
#'
#' #check S and I
#' currentState(model)
#'
#' @export
setMethod("estimateInfectiousNode", signature("seirdModel"),
          function(epiModel, deaths, nderiv){
            #call the SIRD method
            epiModel <- methods::selectMethod(estimateInfectiousNode, "sirdModel")(
              epiModel,
              deaths
            )
            #get parameters/current state
            changeTimes <- epiModel@parameters$changeTimes
            time <- epiModel@currentState$t
            Beta <- epiModel@parameters$Betas[whichIndex(time, changeTimes)]
            Gamma <- epiModel@parameters$Gamma
            Alpha <- epiModel@parameters$Alpha
            Lambda <- epiModel@parameters$Lambda
            S <- epiModel@currentState$S
            D <- epiModel@currentState$D
            R <- epiModel@currentState$R
            N <- Reduce("+", epiModel@initialState)
            #set up functions
            Sf <- function(t){S}
            Df <- function(t){D}
            Rf <- function(t){R}
            If <- function(t, value){value}
            Ef <- function(t, value){N - S - D - R - value}
            #value is a placeholder to be filled with the value of I
            #setup derivatives
            drule <- Deriv::drule #a copy of the derivative rules from Deriv
            drule[["Sf"]] <-alist(t=-Beta*If(t,value)*Sf(t)/N)
            drule[["Ef"]] <-alist(t=Beta*If(t,value)*Sf(t)/N - Lambda*Ef(t,value))
            drule[["If"]] <-alist(t=Lambda*Ef(t,value) - (Alpha + Gamma)*If(t,value))
            drule[["Df"]] <-alist(t=Alpha*If(t,value))
            drule[["Rf"]] <-alist(t=Gamma*If(t,value))
            #use Deriv to calculate nth derivative
            nthDf <- Deriv::Deriv(Df, "t", nderiv = nderiv, drule=drule)
            #calculate the scaling factor
            value <- N - S - D - R
            scalingFactor <- abs(nthDf(time))
            value <- 0
            scalingFactor <- (scalingFactor + abs(nthDf(time)))/2

            #set up optimization function
            optimFunc <- function(I){
              assign("value", I, pos = environment(nthDf))
              value <- (nthDf(time)/scalingFactor)^2
            }
            #optimise
            result <- stats::optim((N-S-D-R)/2, optimFunc, method = "L-BFGS-B", lower = 0, upper = N-S-D-R)
            if(result$convergence != 0){
              stop(result$message)
            }
            I <- result$par
            #assign
            epiModel@currentState$I <- I
            epiModel@currentState$E <- N - S - D - R - I
            return(epiModel)
          }
)
